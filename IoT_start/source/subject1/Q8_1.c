#include <stdio.h>

/*

문제8. 아래의 세부 요구사항에서 제시하는 정렬 알고리즘의 원리를 우선 이해하세요.
그리고 이를 기반으로, 총 다섯 개의 숫자를 입력 받아서
작은 수에서 큰 수의 순으로 정렬하여 출력하는 프로그램을 작성해보세요.

● 세부 요구사항
• 총 다섯 개의 숫자를 입력 받기 위해서 길이가 5인 int형 배열을 선언하세요.
• 다섯 개의 숫자를 배열에 저장한 다음에, 작은 수에서 큰 수의 순서로 정렬을 하세요. 그리고 정렬된 순서대로 출력해보세요.

여러 가지 정렬 알고리즘 가운데 가장 간단한 버블 정렬(bubble sort) 알고리즘을 활용하세요.

문제8 실행의 예

숫자 1 입력: 3
숫자 2 입력: 2
숫자 3 입력: 5
숫자 4 입력: 1
숫자 5 입력 : 4

정렬된 출력:12345

*/

int main_q8_1(void)
{				
	int arr[5] = { 0 };						// 5개의 공간을 가진 정수 배열
	int temp = 0;
	int cnt;								
	cnt = sizeof(arr) / sizeof(arr[0]);		// 정렬할 자료의 수(입력할 자료의 수)

	// 배열의 각 요소에 키보드로 값을 입력받아 넣어준다(배열 공간 개수)
	for (int i = 0; i < cnt; i++)
	{
		printf("숫자 %d 입력: ",i + 1);
		scanf("%d", &arr[i]);
	}


	// 정렬 수행부 (거품정렬)
	// 한번 사이클이 돌때마다 가장 큰값이 오른쪽에 정렬된다.
	// 즉, 사이클이 돌수록 탐색범위를 줄여도 된다(최적화 - 굳이 안해도 되긴함)

	for (int i = 0; i < cnt - 1; i++)				// 반복횟수는 n-1번 이면 충분(한번 할때마다 가장 오른쪽에 제일 큰값이 저장되므로(하나씩 채워져 가는 느낌)
	{
		for (int j = 0; j < (cnt - i) - 1; j++)		// (cnt - i) - 1 : 사이클이 돌수록 탐색범위를 줄여도 된다(최적화 - 굳이 안해도 되긴함)(맨 우측에 항상 큰 값이 점점 쌓임)
		{
			if (arr[j] > arr[j + 1])				// 둘(i,i+1) 사이의 크기비교
			{
				// 값의 이동은 체스나 턴제게임과 같다. 겹칠수 없고 한번에 한개만 움직일수 있다는 것을 알아야함.
				temp = arr[j];						// 왼쪽이 더 크면 그 값을 temp에 저장
				arr[j] = arr[j + 1];				// 오른쪽의 값(작은 값 = i+1)을 왼쪽(i)에 저장(덮어씌움 - temp에 저장한 이유)
				arr[j + 1] = temp;					// temp에 저장된 큰 값을 오른쪽에 저장(덮어쓰기)
			}										// 이렇게 반복하면 크기순으로 정렬됨
		}										
	}
	
	// 정렬 결과 출력
	printf("정렬된 출력:");
	for (int i = 0; i < 5; i++)
	{
		printf("%d ", arr[i]);
	}

	return 0;
}
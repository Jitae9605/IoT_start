#include <stdio.h>


// ========================================= 함수 선언부 ====================================================================

// 예제1 함수선언 

// ========================================= main 함수 ====================================================================

int main(void)
{
	//	19. 파일입출력
	//	파일의 생성 및 수정 그리고 삭제를 다룰수 있다.
	//	* 참고 - 현재디렉토리경로 : D:\\1_IoT\\IoT_start\\IoT_start


	printf("\n------------------- < 1) 파일열고 닫기(fopen함수, fclose 함수) > ---------------------------------------------\n\n");

	//	fopen : 파일을 연다.
	//	fclose : 파일을 닫는다.
	
	FILE* fp_1;

	fp_1 = fopen("19_a.txt", "r");						// 파일 열기
	if (fp_1 == NULL)								// 해당이름의 파일이 존재하지 않은 경우의 처리
	{
		printf("파일이 열리지 않았습니다.\n");
		return 1;
	}

	printf("파일이 열렸습니다.\n");
	fclose(fp_1);									// 파일 닫기

	//	* 참고1 
	//	fopen의 꼴 : fopen("파일명.확장자","명령어");
	//	여기서 파일의 경로는 '현재 작업디렉토리'로 자동으로 기입되어 생략된것이다. 만약 다른 폴더/위치의 파일의 개방을 원한다면 
	//	절대경로 : "파일경로\\파일명.확장자"
	//	상대경로	: "현재디렉토리로부터의 파일경로\\파일명.확장자"

	//	** 참고2
	//	명령어는 r,w,a의 세가지가 있다.
	//	r = 읽기위해 개방. 파일이 없으면 NULL반환
	//	w = 파일내용을 지우고 쓰기위해 개방. 해당 파일이 없으면 파일을 생성
	//	a = 파일의 끝에 추가하기위해 개방. 해당 파일이 없으면 파일을 생성

	//	!!! 주의사항 !!!

	//	1) 경로설정할때 경로의 모든 역슬래시를 한번씩 더 추가해줘야한다.
	//	ex ) c:\source\19_a.txt	->	c:\\source\\19_a.txt  

	//	2) 상위경로/폴더로 가야한다면 .. 을 사용
	//	ex) c---ㅁ(목표위치(B))
	//		|----ㅁ(현재위치(A))
	//		이러한 상황에서 B의 19_a.txt를 열려면 먼저 c로 간다음 B를 열고 19_a.txt를 열어야한다.

	//		fopen("c:\\B\\19_a.txt","r");		-	절대경로
	//		또는	
	//		fopen("..\\B\\19_a.txt","r");		-	상대경로

	printf("\n------------------- < 2) 파일 입출력(fgetc함수) > ---------------------------------------------\n\n");

	//	fgetc함수 : 파일에 적힌 내용을 읽어서 cmd에 출력
	//				파일내의 내용을 모두 읽었으면 (더이상 읽을 내용이 없으면) EOF를 반환

	FILE* fp_2;
	int ch_2;

	// fp_2 = fopen("19_a.txt", "r");									// 상대경로
	fp_2 = fopen("D:\\1_IoT\\IoT_start\\IoT_start\\19_a.txt", "r");	// 절대경로
	if (fp_2 == NULL)
	{
		printf("파일이 열리지 않았습니다.\n");
		return 1;
	}

	while (1)
	{
		ch_2 = fgetc(fp_2);							// 개방한 파일에서 하나의 문자 입력받아온다.
		if (ch_2 == EOF)							// 함수반환값이 EOF(= -1)이면 종료	(fgetc은 모든 데이터를 읽어왔다면 EOF를 반환)
		{
			break;
		}
		putchar(ch_2);								// 입력한 문자 화면출력
	}
	fclose(fp_2);									// 파일 닫음

	printf("\n------------------- < 3) 입력받은 문자열을 파일로 출력(fputs함수) > ---------------------------------------------\n\n");

	//	fputs는 문자열을 파일로 출력할때 사용하는 함수
	//	단 문자열을 버퍼에 모두 저장하고 난 다음 파일로 출력한다.

	FILE* fp_3;
	char str_3[] = "banana";
	int ch_3;

	fp_3 = fopen("19_b.txt", "w");
	if (fp_3 == NULL)
	{
		printf("파일을 출력하지 못했습니다.\n");
		return 1;
	}


	
	int i = 0;
	while (str_3[i] != 0)					//	널문자가 아니면
	{
		fputc(str_3[i], fp_3);				//	문자를 파일에 출력
		i++;
	}
	fputc('\n', fp_3);						//	파일의 끝에 줄넘김을 추가


	fclose(fp_3);

	// 문자가 잘 입력됬는지 확인하기 위한 파일내용 출력

	printf("문자가 파일에 입력됬는지 확인하기 위한 파일내용 출력\n");
	fp_3 = fopen("D:\\1_IoT\\IoT_start\\IoT_start\\19_b.txt", "r");	// 절대경로

	while (1)								
	{
		ch_3 = fgetc(fp_3);							// 개방한 파일에서 하나의 문자 입력받아온다.
		if (ch_3 == EOF)							// 함수반환값이 EOF(= -1)이면 종료	(fgetc은 모든 데이터를 읽어왔다면 EOF를 반환)
		{
			break;
		}
		putchar(ch_3);								// 입력한 문자 화면출력
	}

	fclose(fp_3);

	printf("\n------------------- < 4) 표준입출력을 통한 문자열 입력 > ---------------------------------------------\n\n");
	//	표준 입출력 함수들은 자동으로 운영체제가 stdin,stdout,stderr등의 파일스트림을 구성해서 보조한다.
	
	//	(stdin	= 표준입력 스트림 = 키보드와 연결됨) - 키보드로부터 받아옴			(입력)
	//	(stdout = 표준출력 스트림 = 모니터와 연결됨) - 모니터로 내보냄				(출력)
	//	(stderr = 표준에러 스트림 = 모니터와 연결됨) - 모니터로 내보냄(오류코드 등)	(출력)

	//	* 스트림은 기본적으로 포인터임
	//	단, fgetc나 fputs와 같이 기본으로 스트림이 지정되어 있지 않거나 따로 지정해서 사용가능한 함수가 있다는 것을 기억할 것 !
	
	int ch_4;

	while (1)
	{
		ch_4 = fgetc(stdin);			// 키보드로 문자입력
		if (ch_4 == EOF)				// ctrl + z로 종료
		{
			break;
		}
		fputc(ch_4, stdout);			// 화면에 출력
	}

	//	연결된 키보드로 입력을 받으면 stdin의 버퍼로 입력되고(fgetc(stdin) 그 내용이 다시 ch_4에 입력된다(ch_4 = fgets(stdin))
	//	stdout으로 인해 ch_4의 내용이 stdout의 버퍼로 입력되고 stdout에 연결된 모니터로 정보를 넘긴다. (fputc(ch_4,stdout)) 

	return 0;
}


	
// ========================================= 함수 정의부 ====================================================================

//	3) getchar 함수를 이용한 문자열 입력 함수정의
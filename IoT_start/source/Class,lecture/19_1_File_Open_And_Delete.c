#include <stdio.h>
#include <string.h>


// ========================================= 함수 선언부 ====================================================================

// 예제1 함수선언 

// ========================================= main 함수 ====================================================================

int main(void)
{
	//	19. 파일입출력
	//	파일의 생성 및 수정 그리고 삭제를 다룰수 있다.
	//	* 참고 - 현재디렉토리경로 : D:\\1_IoT\\IoT_start\\IoT_start


	printf("\n------------------- < 1) 파일열고 닫기(fopen함수, fclose 함수) > ---------------------------------------------\n\n");

	//	fopen : 파일을 연다.
	//	fclose : 파일을 닫는다.
	
	FILE* fp_1;

	fp_1 = fopen("Temp\\19_1_a.txt", "r");						// 파일 열기
	if (fp_1 == NULL)								// 해당이름의 파일이 존재하지 않은 경우의 처리
	{
		printf("파일이 열리지 않았습니다.\n");
		return 1;
	}

	printf("파일이 열렸습니다.\n");
	fclose(fp_1);									// 파일 닫기

	//	* 참고1 
	//	fopen의 꼴 : fopen("파일명.확장자","명령어");
	//	여기서 파일의 경로는 '현재 작업디렉토리'로 자동으로 기입되어 생략된것이다. 만약 다른 폴더/위치의 파일의 개방을 원한다면 
	//	절대경로 : "파일경로\\파일명.확장자"
	//	상대경로	: "현재디렉토리로부터의 파일경로\\파일명.확장자"

	//	** 참고2
	//	명령어는 r,w,a의 세가지가 있다.
	//	r = 읽기위해 개방. 파일이 없으면 NULL반환
	//	w = 파일내용을 지우고 쓰기위해 개방. 해당 파일이 없으면 파일을 생성
	//	a = 파일의 끝에 추가하기위해 개방. 해당 파일이 없으면 파일을 생성

	//	!!! 주의사항 !!!

	//	1) 경로설정할때 경로의 모든 역슬래시를 한번씩 더 추가해줘야한다.
	//	ex ) c:\source\19_1_a.txt	->	c:\\source\\19_1_a.txt  

	//	2) 상위경로/폴더로 가야한다면 .. 을 사용
	//	ex) c---ㅁ(목표위치(B))
	//		|----ㅁ(현재위치(A))
	//		이러한 상황에서 B의 19_1_a.txt를 열려면 먼저 c로 간다음 B를 열고 19_1_a.txt를 열어야한다.

	//		fopen("c:\\B\\19_1_a.txt","r");		-	절대경로
	//		또는	
	//		fopen("..\\B\\19_1_a.txt","r");		-	상대경로

	printf("\n------------------- < 2) 파일 입출력(fgetc함수) > ---------------------------------------------\n\n");

	//	fgetc함수 : 파일에 적힌 내용을 읽어서 cmd에 출력
	//				파일내의 내용을 모두 읽었으면 (더이상 읽을 내용이 없으면) EOF를 반환

	FILE* fp_2;
	int ch_2;

	// fp_2 = fopen("Temp\\19_1_a.txt", "r");									// 상대경로
	fp_2 = fopen("D:\\1_IoT\\IoT_start\\IoT_start\\Temp\\19_1_a.txt", "r");	// 절대경로
	if (fp_2 == NULL)
	{
		printf("파일이 열리지 않았습니다.\n");
		return 1;
	}

	while (1)
	{
		ch_2 = fgetc(fp_2);							// 개방한 파일에서 하나의 문자 입력받아온다.
		if (ch_2 == EOF)							// 함수반환값이 EOF(= -1)이면 종료	(fgetc은 모든 데이터를 읽어왔다면 EOF를 반환)
		{
			break;
		}
		putchar(ch_2);								// 입력한 문자 화면출력
	}
	fclose(fp_2);									// 파일 닫음

	printf("\n------------------- < 3) 입력받은 문자열을 파일로 출력(fputs함수) > ---------------------------------------------\n\n");

	//	fputs는 문자열을 파일로 출력할때 사용하는 함수
	//	단 문자열을 버퍼에 모두 저장하고 난 다음 파일로 출력한다.

	FILE* fp_3;
	char str_3[] = "banana";
	int ch_3;

	fp_3 = fopen("Temp\\19_1_b.txt", "w");
	if (fp_3 == NULL)
	{
		printf("파일을 출력하지 못했습니다.\n");
		return 1;
	}


	
	int i = 0;
	while (str_3[i] != 0)					//	널문자가 아니면
	{
		fputc(str_3[i], fp_3);				//	문자를 파일에 출력
		i++;
	}
	fputc('\n', fp_3);						//	파일의 끝에 줄넘김을 추가


	fclose(fp_3);

	// 문자가 잘 입력됬는지 확인하기 위한 파일내용 출력

	printf("문자가 파일에 입력됬는지 확인하기 위한 파일내용 출력\n");
	fp_3 = fopen("D:\\1_IoT\\IoT_start\\IoT_start\\Temp\\19_1_b.txt", "r");	// 절대경로

	while (1)								
	{
		ch_3 = fgetc(fp_3);							// 개방한 파일에서 하나의 문자 입력받아온다.
		if (ch_3 == EOF)							// 함수반환값이 EOF(= -1)이면 종료	(fgetc은 모든 데이터를 읽어왔다면 EOF를 반환)
		{
			break;
		}
		putchar(ch_3);								// 입력한 문자 화면출력
	}

	fclose(fp_3);

	printf("\n------------------- < 4) 표준입출력을 통한 문자열 입력 > ---------------------------------------------\n\n");
	//	표준 입출력 함수들은 자동으로 운영체제가 stdin,stdout,stderr등의 파일스트림을 구성해서 보조한다.
	
	//	(stdin	= 표준입력 스트림 = 키보드와 연결됨) - 키보드로부터 받아옴			(입력)
	//	(stdout = 표준출력 스트림 = 모니터와 연결됨) - 모니터로 내보냄				(출력)
	//	(stderr = 표준에러 스트림 = 모니터와 연결됨) - 모니터로 내보냄(오류코드 등)	(출력)

	//	* 스트림은 기본적으로 포인터임
	//	단, fgetc나 fputs와 같이 기본으로 스트림이 지정되어 있지 않거나 따로 지정해서 사용가능한 함수가 있다는 것을 기억할 것 !
	
	int ch_4;
	printf("입력받은 문자열 저장없이 버퍼에서 다시출력 (종료: ctrl + z)");
	while (1)
	{
		ch_4 = fgetc(stdin);			// 키보드로 문자입력
		if (ch_4 == EOF)				// ctrl + z로 종료
		{
			break;
		}
		fputc(ch_4, stdout);			// 화면에 출력
	}

	//	연결된 키보드로 입력을 받으면 stdin의 버퍼로 입력되고(fgetc(stdin) 그 내용이 다시 ch_4에 입력된다(ch_4 = fgets(stdin))
	//	stdout으로 인해 ch_4의 내용이 stdout의 버퍼로 입력되고 stdout에 연결된 모니터로 정보를 넘긴다. (fputc(ch_4,stdout)) 

	printf("\n------------------- < 5) 개방할 파일의 형식(텍스트(t) 바이너리(b)) > ---------------------------------------------\n\n");

	// 파일을 개방할때 실제로는 r,w,a가 총 6사지의 종류가 있다
	//	텍스트파일 개방		 = rt, wt, at
	//	텍스트이외의 파일 개방 = rb, wb, ab
	//	단, default값으로 앞에 t가 붙어있어서 이전 실습에서의 파일개방에 문제가 없었던 것!

	FILE* fp_5;
	int ary_5[10] = { 13, 10, 13, 13, 10, 26, 13, 10, 13, 10 };
	int res_5;

	fp_5 = fopen("Temp\\19_1_5_a.txt", "wb");
	for (int i = 0; i < 10; i++)
	{
		fputc(ary_5[i], fp_5);
	}
	fclose(fp_5);

	//	텍스트파일에 저장될때 문자로 입력된다 즉, 아스키코드값으로 저장
	//	그런데 아스키코드상으로 13 = '\r', 10 = '\n', 26 = 'ctrl + z', 으므로 
	//	메모장에는 [ \r \n \r \r \n ctrl+z \r \n \r \n ]이 입력이 된다.
	//	(만들어진 텍스트파일을 열어보면 \r와 \n를 명령어로서 수행함을 알수 있다.) 

	fp_5 = fopen("Temp\\19_1_5_a.txt", "rt");
	while (1)
	{
		res_5 = fgetc(fp_5);
		if (res_5 == EOF) break;
		printf("%4d",res_5);
	}
	fclose(fp_5);

	//	!!! 주의 !!!
	//	입력된 파일을 fgetc로 불러오면 3개의 문자만 입력하고 종료됨을 알수 있다.
	//	fgetc는 읽어올때 /r과 /n이 순서대로 붙어서 읽어지면 /r을 버린다! (윈도우 운영체제의 특징)
	//	또한 아스키코드 26번이 'ztrl + z'를 의미하므로 이를 읽으면서 EOF를 반환하고 종료되는 것!

	//	즉, (13 10)		 13		(13 10)		 26   ~
	//		 13버림				 13버림		종료
	//													출력화면	= 10 13 10 (종료)

	printf("\n------------------- < 6) '+'개방모드와 fseek, rewind, feof 함수 > ---------------------------------------------\n\n");

	// '+' 개방모드
	// 기존의 모드뒤에 +를 붙여 기존에서 읽고쓰기능력을 추가하는것!
	
	// r+ = 텍스트파일에 읽고 쓰기위해 개방
	// w+ = 텍스트파일의 내용을 지우거나 읽고 쓰기위해 개방
	// b+ = 텍스트파일을 읽거나 파일내용의 끝에 추가하기위해 개방
	
	// rb+ = 바이너리파일에 읽고 쓰기위해 개방
	// wb+ = 바이너리파일의 내용을 지우거나 읽고 쓰기위해 개방
	// ab+ = 바이너리파일을 읽거나 파일내용의 끝에 추가하기위해 개방


	FILE* fp_6;
	char str_6[20];

	fp_6 = fopen("Temp\\19_1_6_a.txt", "a+");				// 읽기 가능한 추가보드로 개방
	if (fp_6 == NULL)
	{
		printf("파일을 만들지 못했습니다.\n");
		return 1;
	}

	while (1)
	{
		printf("과일이름 : ");
		scanf("%s", str_6);							// 키보드로 과일이름입력

		if (strcmp(str_6, "end") == 0)				// end를 입력받으면 종료
		{
			break;
		}

		else if (strcmp(str_6, "list") == 0)		// list를 입력받으면 파일내용 출력
		{
			fseek(fp_6, 0, SEEK_SET);				// fseek함수를 이용해 위치지시자를 문서의 맨앞으로 옮김 (*참고1 항목참고)
			while (1)
			{
				fgets(str_6, sizeof(str_6), fp_6);
				if (feof(fp_6))						// 파일을 끝까지 다읽었는지 체크
				{
					break;
				}
				printf("%s", str_6);				// 파일내용 출력(a+ - 읽기)
			}
			
		}
		else
		{
			fprintf(fp_6, "%s\n", str_6);			// list,end가 아니면 str_6에 입력받은 값을 fp_6의 끝에 추가(a+ -  추가)
		}

	}
	fclose(fp_6);

	//	* 참고1
	//	fseek함수 꼴: fseek(파일 포인터,오프셋값, 기준점)
	//	fseek함수는 현재 어디에 입력되고 있는지를 가리키는 '위치지시자'의 위치를 변화시키는 함수이다.
	//	포인터가 가리키는 파일내부의 위치지시자를 기준점으로 옮기고 오프셋값만큼 커서를 움직인다.
	//	기준점은 파일의 처음(SEEK_SET), 현 위치지시자 위치(SEEK_CUR), 파일의 끝(SEEK_END) 3가지이다.
		
	//	** 사용하는 이유
	//	입력을 진행중일때 한줄을 입력하면 자동으로 위치지시자는 다음의 빈줄을 가리키게 되는데
	//	이를 fseek을 이용해 문서의 맨앞으로 돌리고 한줄씩 출력하여 순서대로 전체 내용을 출력할수 있다.

	//	*** 참고2
	//	간단하게 rewind를 써서 문서의 처음을 가리키게 할수도 있다.
	//	fseek(fp_6,0,SEEK_SET) == rewind(fp_6) 이다.

	//	**** 참고3
	//	feof(fp_6)는 fp_6파일의 데이터를 모두 읽었을때(EOF상태) 참값을 반환한다.



	return 0;
}


	
// ========================================= 함수 정의부 ====================================================================

//	3) getchar 함수를 이용한 문자열 입력 함수정의
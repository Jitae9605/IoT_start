#include <stdio.h>

// ========================================= 함수 선언부 ====================================================================

// 예제1 함수선언 
void swap_double_ptr(char** ppa, char** ppb);	// [ 이중포인터를 이용한 포인터교환 ]

// 예제2 함수선언 
void swap_ptr(char** ppa, char** ppb);			// [ 포인터를 이용한 포인터 교환 ]

// 2) 포인터배열 함수선언
void print_str(char** pps, int cnt);

// ========================================= main 함수 ====================================================================

int main(void)
{
	// 14. 응용포인터와 배열포인터

	printf("\n------------------- < 1) 이중포인터 개념 및 사용 > ---------------------------------------------\n");
	// 1) 이중포인터 개념 및 사용
	int a = 10;
	int* pi;
	int** ppi;

	pi = &a;
	ppi = &pi;

	printf("변수 \t 변숫값 \t&연산 \t\t*연산 \t **연산 \t\n\n");
	printf("a   %10d \t %10u\n",a, &a);												//	a값			a주소값
	printf("pi  %10u \t %10u \t %10d\n", pi, &pi, *pi);								//	a주소값		pi주소값		a값
	printf("ppi %10u \t %10u \t %10u \t %10u\n", ppi, &ppi, *ppi, **ppi);			//	pi주소값		ppi주소값	a주소값	a값
		
	//	결국 포인터는 값으로 다른 변수의 ㅈ소값을 가지는 것으로 그 자신도 주소를 가지고 있다
	//	이중 포인터는 또하나의 포인터를 선언해 기존의 포인터의 주소를 저장하는 것으로
	//	포인터ppi -> 포인터pi -> 변수a 를 가지게 하는것
	//	
	//	즉, ppi를 출력하면
	// 
	//	ppi = pi의 주소값		( = &pi) 
	// 
	//	&ppi = ppi의 주소값		( = &ppi )
	// 
	//	*ppi = ppi의 값에 해당하는 주소의 메모리공간에 저장된 값 = pi에 저장된 값 = pi값
	//				( = *(&pi) = pi )
	// 
	//	**ppi = ppi의 값에 해당하는 주소의 메모리공간에 저장된 값을 다시 주소로서 해당 주소에 해당하는 메모리공간속의 값
	//				= pi의 값에 해당하는 주소의 메모리공간에 저장된 값 = a에 저장된 값 = a값
	//					( = **ppi = *(*(&pi)) = *pi = *(&a)) = a )	

	printf("\n------------------- < 예제1 > ---------------------------------------------\n\n");
	char* pa_ex1 = "success";
	char* pb_ex1 = "failure";

	printf(" 변경전 : pa -> %s, pb -> %s\n", pa_ex1, pb_ex1);
	swap_double_ptr(&pa_ex1, &pb_ex1);
	printf(" 변경후 : pa -> %s, pb -> %s\n", pa_ex1, pb_ex1);

	printf("\n------------------- < 예제2 > ---------------------------------------------\n\n");
	char* pa_ex2 = "success";
	char* pb_ex2 = "failure";

	printf(" 변경전 : pa -> %s, pb -> %s\n", pa_ex2, pb_ex2);
	swap_ptr(&pa_ex2, &pb_ex2);
	printf(" 변경후 : pa -> %s, pb -> %s\n", pa_ex2, pb_ex2);

	printf("\n------------------- < 2) 포인터배열 > ---------------------------------------------\n");

	char* ptr_ary[] = { "eagle","tiger","lion", "squirrel" };		// 포인터배열 초기화
	int count;			// 배열요소갯수 저장변수

	count = sizeof(ptr_ary) / sizeof(ptr_ary[0]);	// 배열요소수 계산
	print_str(ptr_ary, count);						// 배열명과 배열요소수 주고 호출

	//	배열명 자체가 주소다
	//	즉, prt_ary = &ptr_ary[0]
	
	//	게다가 포인터 배열의 경우 각 요소(문자열)은 각각 실제 문자열처럼 주소를 가진다
	//	즉, "eagel" "tiger"등의 각 배열요소는 주소를 가지고 있다.

	printf("\n------------------- < 3) 포인터배열의 주소와 요소번호의 상관관계 > ---------------------------------------------\n");

	int ary_3[5];

	printf(" ary_3의 값 : \t\t%u\t\n", ary_3);				
	printf(" ary_3의 주소값 : \t%u\t\n", &ary_3);			// 주소로서의 배열명의 값	( 위와 값이 같다 =  < ary_3 = &ary_3 = &ary_3[0] > )
	printf(" ary_3 + 1의값 : \t%u\t\n", ary_3 + 1);		// 배열의 주소
	printf(" &ary_3 + 1의 값 : \t%u\t\n", &ary_3 + 1);

	// "%u", ary_3 + 1 = ary_3[0 + 1] 이므로 ary_3[1]의 주소를 의미하고 자료형이 int이므로 4만큼의 크기차이가 난다.
	// "%u", &ary_3 + 1 = ary_3 배열 자체의 주소 + 1 을 의미하고 이는 배열 전체의 다음번지를 의미하므로 
	//		= { &ary_3[0] + (요소수 * 자료형의 크기) } = { &ary_3[0] + (4 * 5) } = { &ary_3[0] + 20 } 


	return 0;
}

// ========================================= 함수 정의부 ====================================================================

// 예제1 함수정의
void swap_double_ptr(char** ppa, char** ppb)	// [ 이중포인터를 이용한 포인터교환 ]
{
	//	포인터의 주소를 매개변수로 이중포인터에 저장하고 포인터의 주소값을 값으로 가진 이중포인터간에 값을 교환
	// 
	//	즉, char **ppa = *(*(&pa_ex1)) = *("succece")
	//		char **ppb = *(*(&pb_ex2)) = *("failure")
	// 
	//	이때, "succec", "failure" 은 문자열이므로 자체적인 주소값을 가지고있다.
	//	즉, **ppa 는 "suceece" 배열의 주소값내의 값을 가리키게 되고,
	//		**ppb 는 "failure" 배열의 주소값내의 값을 가리킨다.

	char* pt;

	pt = *ppa;
	*ppa = *ppb;
	*ppb = pt;
}

// 예제2 함수정의
void swap_ptr(char* ppa, char* ppb)			// [ 포인터를 이용한 포인터 교환 ]
{
	//	main에서의 호출꼴 = swap_ptr(&pa_ex2, &pb_ex2);
	//	생략되었지만 실제로는 아래의 내용이 추가 되어있는 것
	//	--------------------------
	//	char* ppa, ppb;
	//	ppa = &pa_ex2;
	//	ppb = &pb_ex2;
	//	--------------------------

	char pt ;

	pt = *ppa;				// *ppa = ppa가 가지고 있는 값을 주소로 하는 메모리공간속 값에 접근
	*ppa = *ppb;
	*ppb = pt;

	//	위의 이중포인터와 같지만, 받을때 이중이 아닌 일반 포인터로 받음
	//	그래서 임시 저장하는 temp를 수준을 맞추기 위해 포인터가 아닌 일반 변수로 선언하였고 교환함

	// * 참고 *
	// ppa = &pa_ex2 = pa_ex2의 주소값
	// ppb = &pb_ex2 = pb_ex2의 주소값

}

// 2) 포인터배열 함수정의
void print_str(char** pps, int cnt)
{
	//	main에서의 호출꼴 = print_str(ptr_ary, count);
	//	생략되었지만 실제로는 아래의 내용이 추가 되어있는 것
	//	--------------------------
	//	char** pps;
	//  int cnt;
	//	pps = ptr_ary;		// **pps = *(*(&ptr_ary[0])) = *("eagle" ~ "squirrel)
	//	cnt = count;
	//	--------------------------

	int i;

	for (i = 0; i < cnt; i++)
	{
		printf("%s \n", pps[i]);	// pps[i] = (**pps[i]) = *(*(&ptr_ary[0]) + i) = *( ptr_ary[i] )
	}


}
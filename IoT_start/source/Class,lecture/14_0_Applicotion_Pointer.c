#include <stdio.h>

// ========================================= 함수 선언부 ====================================================================

// 예제1 함수선언 
void swap_double_ptr(char** ppa, char** ppb);	// [ 이중포인터를 이용한 포인터교환 ]

// 예제2 함수선언 
void swap_ptr(char** ppa, char** ppb);			// [ 포인터를 이용한 포인터 교환 ]

// 2) 포인터배열 함수선언
void print_str(char** pps, int cnt);

// 예제3 함수선언
void print_ary_ex3(int(*)[4]);					// [ 배열포인터 출력함수 ]



// ========================================= main 함수 ====================================================================

int main(void)
{
	// 14. 응용포인터와 배열포인터

	printf("\n------------------- < 1) 이중포인터 개념 및 사용 > ---------------------------------------------\n\n");
	// 1) 이중포인터 개념 및 사용
	int a = 10;
	int* pi;
	int** ppi;

	pi = &a;
	ppi = &pi;

	printf("변수 \t 변숫값 \t&연산 \t\t*연산 \t **연산 \t\n\n");
	printf("a   %10d \t %10u\n",a, &a);												//	a값			a주소값
	printf("pi  %10u \t %10u \t %10d\n", pi, &pi, *pi);								//	a주소값		pi주소값		a값
	printf("ppi %10u \t %10u \t %10u \t %10u\n", ppi, &ppi, *ppi, **ppi);			//	pi주소값		ppi주소값	a주소값	a값
		
	//	결국 포인터는 값으로 다른 변수의 ㅈ소값을 가지는 것으로 그 자신도 주소를 가지고 있다
	//	이중 포인터는 또하나의 포인터를 선언해 기존의 포인터의 주소를 저장하는 것으로
	//	포인터ppi -> 포인터pi -> 변수a 를 가지게 하는것
	//	
	//	즉, ppi를 출력하면
	// 
	//	ppi = pi의 주소값		( = &pi) 
	// 
	//	&ppi = ppi의 주소값		( = &ppi )
	// 
	//	*ppi = ppi의 값에 해당하는 주소의 메모리공간에 저장된 값 = pi에 저장된 값 = pi값
	//				( = *(&pi) = pi )
	// 
	//	**ppi = ppi의 값에 해당하는 주소의 메모리공간에 저장된 값을 다시 주소로서 해당 주소에 해당하는 메모리공간속의 값
	//				= pi의 값에 해당하는 주소의 메모리공간에 저장된 값 = a에 저장된 값 = a값
	//					( = **ppi = *(*(&pi)) = *pi = *(&a)) = a )	

	printf("\n------------------- < 예제1 > ---------------------------------------------\n\n");
	
	// 

	char* pa_ex1 = "success";
	char* pb_ex1 = "failure";

	printf(" 변경전 : pa -> %s, pb -> %s\n", pa_ex1, pb_ex1);
	swap_double_ptr(&pa_ex1, &pb_ex1);
	printf(" 변경후 : pa -> %s, pb -> %s\n", pa_ex1, pb_ex1);

	printf("\n------------------- < 예제2 > ---------------------------------------------\n\n");
	char* pa_ex2 = "success";
	char* pb_ex2 = "failure";

	printf(" 변경전 : pa -> %s, pb -> %s\n", pa_ex2, pb_ex2);
	swap_ptr(&pa_ex2, &pb_ex2);
	printf(" 변경후 : pa -> %s, pb -> %s\n", pa_ex2, pb_ex2);

	printf("\n------------------- < 2) 포인터배열 > ---------------------------------------------\n\n");
	// 포인터를 배열로 선언 

	char* ptr_ary[] = { "eagle","tiger","lion", "squirrel" };		// 포인터배열 초기화
	int count;			// 배열요소갯수 저장변수

	count = sizeof(ptr_ary) / sizeof(ptr_ary[0]);	// 배열요소수 계산
	print_str(ptr_ary, count);						// 배열명과 배열요소수 주고 호출

	//	배열명 자체가 주소다
	//	즉, prt_ary = &ptr_ary[0]
	
	//	게다가 포인터 배열의 경우 각 요소(문자열)은 각각 실제 문자열처럼 주소를 가진다
	//	즉, "eagel" "tiger"등의 각 배열요소는 주소를 가지고 있다.

	printf("\n------------------- < 3) 포인터배열의 주소와 요소번호의 상관관계 > ---------------------------------------------\n\n");

	int ary_3[5];

	printf(" ary_3의 값 : \t\t%u\t\n", ary_3);				
	printf(" ary_3의 주소값 : \t%u\t\n", &ary_3);			// 주소로서의 배열명의 값	( 위와 값이 같다 =  < ary_3 = &ary_3 = &ary_3[0] > )
	printf(" ary_3 + 1의값 : \t%u\t\n", ary_3 + 1);		// 배열의 주소
	printf(" &ary_3 + 1의 값 : \t%u\t\n", &ary_3 + 1);

	// "%u", ary_3 + 1 = ary_3[0 + 1] 이므로 ary_3[1]의 주소를 의미하고 자료형이 int이므로 4만큼의 크기차이가 난다.
	// "%u", &ary_3 + 1 = ary_3 배열 자체의 주소 + 1 을 의미하고 이는 배열 전체의 다음번지를 의미하므로 
	//		= { &ary_3[0] + (요소수 * 자료형의 크기) } = { &ary_3[0] + (4 * 5) } = { &ary_3[0] + 20 } 

	printf("\n------------------- < 4) 배열 포인터 > ---------------------------------------------\n\n");

	// 배열형태의 포인터 - 2차원 배열저장가능
	int ary_4[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };
	int(*pa_4)[4];				// int형 변수 4개의 배열을 가리키는 배열 포인터 ( !!! 괄호 반드시 해야함 !!! )
	pa_4 = ary_4;				

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			printf("%5d", pa_4[i][j]);			// pa_4를 2차원 배열처럼 사용
		}
		printf("\n");
	}

	printf("\n------------------- < 예제 3 > ---------------------------------------------\n\n");

	int ary_ex3[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };

	print_ary_ex3(ary_ex3);

	printf("\n------------------- < 5) 2차원 배열 요소참조 원리 > ---------------------------------------------\n\n");

	int ary_5[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };

	// 둘은 같다 ( ary_5 전체 배열의 주소값 )
	printf(" < ary_5 전체 배열의 주소값 >\n");
	printf(" ary_5의 값 : \t\t\t\t\t%u\t\n", ary_5);
	printf(" ary_5의 2차원 배열 전체의 주소값 : \t\t%u\t\n\n", &ary_5);		

	// 모두 같다 ( ary_5[1]의 주소값 )
	printf(" < ary_5[1]의 주소값 >\n");
	printf(" ary_5 + 1의값 : \t\t\t\t\t%u\t\n", ary_5 + 1);		
	printf(" &ary_5[0] + ( 1 * sizeof(ary_5[0]))의 값 : \t\t%u\t\n", ((int)(&ary_5[0])) + ( 1 * sizeof(ary_5[0]))); // (int)를 추가한 이유는 ary_5 + num 은 ary_5[num]으로 자동 계산되서 
	printf(" *(ary_5 + 1)의 값 : \t\t\t\t\t%u\t\n", *(ary_5 + 1));
	printf(" ary_5[1]의 주소값 : \t\t\t\t\t%u\t\n\n", ary_5[1]);

	//둘은 같다 ( ary_5[1][2]의 주소값 )
	printf(" < ary_5[1][2]의 주소값 >\n");
	printf(" *(ary_5 + 1) + 2의값 :\t\t\t\t\t%u\t\n", *(ary_5 + 1) + 2);
	printf(" *(ary_5 + 1) + ( 2 * sizeof(ary_5[1][0]) )의 값 : \t%u\t\n\n", ((int)*(ary_5 + 1)) + (2 * sizeof(ary_5[1][0]))); // (int)를 추가한 이유는 ary_5 + num 은 ary_5[num]으로 자동 계산되서 

	// 둘은 같다 ( ary_5[1][2]의 값 )
	printf(" < ary_5[1][2]의 값 >\n");
	printf(" *(*(ary_5 + 1) + 2)의값 : \t\t%u\t\n", *(*(ary_5 + 1) + 2));
	printf(" ary_5[1][2]의 값 : \t\t\t%u\t\n\n", ary_5[1][2]);

	//	!!! &ary_5 = 100 으로 가정 !!!
	
	//	ary_5 + 1 = &ary_5[0] + ( 1 * sizeof(ary_5[0]) ) = 100 + (1 * 16 ) = 116
	//	*(ary_5 + 1) = ary_5[1]
	//	*(ary_5 + 1) + 2 = *(ary_5 + 1) + ( 2 * sizeof(ary_5[1][0]) ) = 116 + (2 * 4) = 124
	//	*(*(ary_5 + 1) + 2) = ary_5[1][2]

	//	* 정리 * 
	//	&ary_5			= 2차원 배열 전체의 주소
	//	ary_5			= 첫 번째 부분배열의 주소
	//	&ary_5[0]		= 첫 번째 부분배열의 주소
	//	ary_5[0]		= 첫 번째 부분배열의 첫 번째 배열 요소의 주소
	//	&ary_5[0][0]	= 첫 번째 부분배열의 첫 번째 배열 요소의 주소

	//	단,
	//	sizeof(ary_5)			= 배열전체의 크기			= 48	바이트
	//	sizeof(&ary_5[0])		= 주소의 크기			= 4		바이트
	//	sizeof(ary_5[0])		= 부분배열 전체의 크기	= 16	바이트
	//	sizeof(&ary_5[0][0])	= 주소의 크기			= 4		바이트






	return 0;
}

// ========================================= 함수 정의부 ====================================================================

// 예제1 함수정의
void swap_double_ptr(char** ppa, char** ppb)	// [ 이중포인터를 이용한 포인터교환 ]
{
	//	포인터의 주소를 매개변수로 이중포인터에 저장하고 포인터의 주소값을 값으로 가진 이중포인터간에 값을 교환
	// 
	//	즉, char **ppa = *(*(&pa_ex1)) = *("succece")
	//		char **ppb = *(*(&pb_ex2)) = *("failure")
	// 
	//	이때, "succec", "failure" 은 문자열이므로 자체적인 주소값을 가지고있다.
	//	즉, **ppa 는 "suceece" 배열의 주소값내의 값을 가리키게 되고,
	//		**ppb 는 "failure" 배열의 주소값내의 값을 가리킨다.

	char* pt;

	pt = *ppa;
	*ppa = *ppb;
	*ppb = pt;
}

// 예제2 함수정의
void swap_ptr(char* ppa, char* ppb)			// [ 포인터를 이용한 포인터 교환 ]
{
	//	main에서의 호출꼴 = swap_ptr(&pa_ex2, &pb_ex2);
	//	생략되었지만 실제로는 아래의 내용이 추가 되어있는 것
	//	--------------------------
	//	char* ppa, ppb;
	//	ppa = &pa_ex2;
	//	ppb = &pb_ex2;
	//	--------------------------

	char pt ;

	pt = *ppa;				// *ppa = ppa가 가지고 있는 값을 주소로 하는 메모리공간속 값에 접근
	*ppa = *ppb;
	*ppb = pt;

	//	위의 이중포인터와 같지만, 받을때 이중이 아닌 일반 포인터로 받음
	//	그래서 임시 저장하는 temp를 수준을 맞추기 위해 포인터가 아닌 일반 변수로 선언하였고 교환함

	// * 참고 *
	// ppa = &pa_ex2 = pa_ex2의 주소값
	// ppb = &pb_ex2 = pb_ex2의 주소값

}

// 2) 포인터배열 함수정의
void print_str(char** pps, int cnt)
{
	//	main에서의 호출꼴 = print_str(ptr_ary, count);
	//	생략되었지만 실제로는 아래의 내용이 추가 되어있는 것
	//	--------------------------
	//	char** pps;
	//  int cnt;
	//	pps = ptr_ary;		// **pps = *(*(&ptr_ary[0])) = *("eagle" ~ "squirrel)
	//	cnt = count;
	//	--------------------------

	int i;

	for (i = 0; i < cnt; i++)
	{
		printf("%s \n", pps[i]);	// pps[i] = (**pps[i]) = *(*(&ptr_ary[0]) + i) = *( ptr_ary[i] )
	}


}

// 예제3 함수정의
void print_ary_ex3(int(*pa)[4])			// [ 배열포인터 출력함수 ]
{
	int i, j;
	

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			printf("%5d", pa[i][j]);			// pa_4를 2차원 배열처럼 사용
		}
		printf("\n");
	}
}


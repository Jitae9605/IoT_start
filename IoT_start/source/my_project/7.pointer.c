#include <stdio.h>

// 함수 선언
void swap(int a, int b); // swap함수 단순 a,b를 사용한 함수
void swap_address(int *a, int *b); // swap을 주소값과 포인터로 하는 함수
void changeArray(int *ptr); // 포인터로 변수받고 배열의 값변경 해주는 함수

int main_pointer(void)
{
	// 포인터 = 바로가기와 비슷하다
	/* 완료한거 주석처리용 - 이거 지우면 됨

	// [철수] : 101호  --> 메모리 공간의 주소 예시
	// [영희] : 201호
	// [민수] : 301호
	// 각 문에는 '암호'가 걸려있음

	int 철수 = 1; //암호
	int 영희 = 2;
	int 민수 = 3;

	// printf문에서 '&변수이름'은 해당 변수의 메모리공간의 주소를 의미한다
	printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);  
	printf("철수네 주소 : %d, 암호 : %d\n", &영희, 영희);
	printf("철수네 주소 : %d, 암호 : %d\n", &민수, 민수);

	printf("----------------------------------\n");

	// 미션수행
	// 첫 번째 미션 : 아파트의 각 집에 방문해 문에 적힌 암호확인
	int * 수행자; // 포인터 변수

	수행자 = &철수;
	printf("수행자가 방문하는 곳 주소 : %d, 암호 :%d\n", 수행자, *수행자);

	수행자 = &영희;
	printf("수행자가 방문하는 곳 주소 : %d, 암호 :%d\n", 수행자, *수행자);

	수행자 = &민수;
	printf("수행자가 방문하는 곳 주소 : %d, 암호 :%d\n", 수행자, *수행자);

	printf("----------------------------------\n");

	// 두번째 미션 : 각 암호에 3을 곱해라
	수행자 = &철수;
	*수행자 = *수행자 * 3;
	printf("수행자가 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 수행자, *수행자);

	수행자 = &영희;
	*수행자 = *수행자 * 3;
	printf("수행자가 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 수행자, *수행자);

	수행자 = &민수;
	*수행자 = *수행자 * 3;
	printf("수행자가 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 수행자, *수행자);

	printf("----------------------------------\n");

	// 스파이
	// 수행자가 바꾼 암호에서 2를 빼라!
	int * 스파이 = 수행자; // 같은 메모리 주소를 여러 포인터가 가리킬수 있다
						  // 결국 바로가기가 하나 더 생기고 그이름이 다른것이다.
	printf("\n... 스파이가 미션을 수행하는 중...\n\n");

	스파이 = &철수;
	*스파이 = *스파이 - 2;
	printf("스파이가 방문하는 곳 주소 : %d, 암호 :%d\n", 스파이, *스파이);

	스파이 = &영희;
	*스파이 = *스파이 - 2;
	printf("스파이가 방문하는 곳 주소 : %d, 암호 :%d\n", 스파이, *스파이);

	스파이 = &민수;
	*스파이 = *스파이 - 2;
	printf("스파이가 방문하는 곳 주소 : %d, 암호 :%d\n", 스파이, *스파이);

	printf("----------------------------------\n");

	printf(" 집주인들은 집에와서 바뀐 암호를 보고 깜짝놀란다\n");
	printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);
	printf("철수네 주소 : %d, 암호 : %d\n", &영희, 영희);
	printf("철수네 주소 : %d, 암호 : %d\n", &민수, 민수);

	printf("----------------------------------\n");

	// 참고로 수행자와 스파이가 사는 곳의 주소도 &수행자, &스파이 로 확인가능
	printf("수행자의 주소 : %d\n", &수행자);
	printf("스파이의 주소 : %d\n", &스파이);

	printf("----------------------------------\n");


	// 배열 ?
	// 1. 포인터의 성질

	int arr[3] = { 5, 10, 15 }; // 배열 arr을 선언 및 정의
	int* ptr = arr; // ptr을 arr의 포인터로 선언
	for (int i = 0; i < 3; i++)
	{
		printf("포인터 ptr[%d] 의 값 : %d\n", i, arr[i]);
		// printf("포인터 ptr[%d] 의 값 : %d\n", i, *(arr + i)); // 위와 같다
		// 위의 문장을 다르게 표현한것 생김새를 제외하고 완전 같다
		// *(arr + i) == arr[i] 똑같은 표현
	}

	// 포인터의 값을 변화 시켰을때포인터가 가르키는 실제의 값(각 배열의 값)도 바뀌는지 확인
	ptr[0] = 100;
	ptr[1] = 200;
	ptr[2] = 300;

	for (int i = 0; i < 3; i++)
	{
		printf("포인터 ptr[%d] 의 값 : %d\n", i, ptr[i]);
		// printf("포인터 ptr[%d] 의 값 : %d\n", i, *(ptr + i)); // 위와 같다
	}
	// 포인터의 값을 바꿨는데 배열의 값도 바뀜
	// 즉, 포인터는 가르키는 대상에 붙은 또 하나의 이름과 같다
	printf("----------------------------------\n");

	// 2. 배열의 주소
	// *(arr + i) == arr[i] 
	// 즉, arr == arr 배열의 첫번째 값의 주소 == &arr[0]
	printf("arr 자체의 값 : %d\n", arr);
	printf("arr[0] 의 주소 : %d\n", &arr[0]);
	printf("arr 자체의 값이 가지는 주소의 실제 값 : %d\n", *arr); // *arr == *(arr + 0)
	printf("arr[0] 의 실제 값 : %d\n", *&arr[0]);  

	printf("----------------------------------\n");
	
	// &변수 = 변수의 주소
	// *변수 = 해당 주소에 존재하는 값
	// *&변수 = 변수의 주소에 존재하는 값  = 그냥 변수의 값을 물어보는 것(서로 상쇄됨)
	// 즉, *&는 아무것도 없는것과 같다 ( *&arr == arr )
	printf("arr[0] 의 실제 값 : %d\n", arr[0]);
	printf("arr[0] 의 실제 값 : %d\n", *&arr[0]);
	printf("arr[0] 의 실제 값 : %d\n", *&*&*&*&*&*&*&*&arr[0]);

	printf("----------------------------------\n");
	
	// SWAP 함수 - < 값의 주소와 포인터의 활용 >
	int a = 10;
	int b = 20;

	// a 와 b 의 값을 바꾼다
	printf("Swap 함수 사용 전 => a : %d, b : %d\n", a, b);
	swap(a, b);
	printf("Swap 함수 사용 후 => a : %d, b : %d\n", a, b);

	// 값에 의한 복사(Call by Value) -> 값만 복사한다는 의미
	// 현재 swap 함수의 a, b는 단순히 받는 값의 이름일뿐이다 실제 main 함수 내의
	// 정의된 a, b가 아니다 (함수 안밖에서 a, b 주소값을 각각 출력/비교 하면 다르다.)
	// printf("a의 주소 : %d\n", &a); // main함수 내의 a의 주소출력
	// printf("b의 주소 : %d\n", &b); // main함수 내의 b의 주소출력
	// 즉, 넘길때 주소값을 넘겨야 main 내의 a, b의 값을 변경 할 수 있다.

	printf("----------------------------------\n");

	// a, b의 값이 아닌 주소를 토대로 Swap을 하는 swap_address 함수
	// main에서 사용할때 &a 와 &b를 넘기고
	// 함수내에서 받고 처리할때 모두 *a 와 *b로 받고 사용/처리한다.
	// 즉, 금고 번호를 보내고 금고번호에 해당하는 물건(값)에 요구사항 처리(함수 수행)

	printf("Swap_address 함수(주소값 전달) 사용 전 => a : %d, b : %d\n", a, b);
	swap_address(&a, &b); // &를 써서 주소를 넘긴다
	printf("Swap_address 함수(주소값 전달) 사용 후 => a : %d, b : %d\n", a, b);
	
	printf("----------------------------------\n");

	완료한거 주석처리용 - 이거 지우면 됨 */
	
	// 포인터로 배열값 변경하기
	
	int arr2[3] = { 10,20,30 };
	changeArray(arr2);  // 배열일때는 배열자체가 주소를 가진다 -> '&'생략
	// changeArray(&arr2[0]);  // 이것도 같은 결과를 나타낸다 ( arr2 = &arr2[0] )

	for (int i = 0; i < 3; i++)
	{
		printf("%d\n", arr2[i]);
	}
	
		return 0;
}

void swap(int a, int b)
{
	// printf("a의 주소 : %d\n", &a); // swap함수 내의 a의 주소출력
	// printf("b의 주소 : %d\n", &b); // swap함수 내의 b의 주소출력
	int temp = a;
	a = b;
	b = temp;
	printf("Swap 내부 => a : %d, b : %d\n", a, b);
}

void swap_address(int *a, int *b)
{
	// 모두 *a 와 *b를 써서 받은 main 함수내의 a와 b의 주소에 해당하는 값에 작업/처리 
	int temp = *a;
	*a = *b;
	*b = temp;
	printf("Swap_address 함수(주소값 전달) 내부 => a : %d, b : %d\n", *a, *b);
}

void changeArray(int *ptr)
{
	ptr[2] = 50;  // 배열일때는 배열자체가 주소를 가진다 
				  //   -> 받을땐 '*'을 써서 포인터로, 함수사용시에는 '&'생략
}